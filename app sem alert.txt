import os
import csv
import time
import json
import psycopg2
import pandas as pd
from io import BytesIO, StringIO
from dotenv import load_dotenv
from functools import wraps
from datetime import timedelta
import bcrypt


from flask import Flask, render_template, request, redirect, url_for, session, make_response
from flask_wtf.csrf import CSRFProtect, generate_csrf
from boxsdk import Client, OAuth2




app = Flask(__name__)
app.config['SECRET_KEY'] = os.getenv('SECRET_KEY')
from flask_wtf.csrf import CSRFProtect
csrf = CSRFProtect(app)


def connect_db():
    required_vars = ["DB_NAME", "DB_USER", "DB_PASSWORD", "DB_HOST"]
    for var in required_vars:
        if not os.getenv(var):
            raise EnvironmentError(f"‚ùå Vari√°vel de ambiente n√£o definida: {var}")
    
    return psycopg2.connect(
        dbname=os.getenv("DB_NAME"),
        user=os.getenv("DB_USER"),
        password=os.getenv("DB_PASSWORD"),
        host=os.getenv("DB_HOST"),
        port=os.getenv("DB_PORT", "5432")
    )

# Fun√ß√£o para desconectar do banco
def disconnect_db(conn):
    if conn:
        conn.close()

def login_requerido(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not session.get('logado'):
            return redirect(url_for('login'))
        return f(*args, **kwargs)
    return decorated_function        

@app.route('/')
def index():
    return render_template('home.html')  # ‚Üê correto para usar {{ csrf_token() }}
# Rota para a p√°gina de login
@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        usuario = request.form.get('usuario')
        senha = request.form.get('senha')
        lembrar = request.form.get('lembrar')

        conn = connect_db()
        cur = conn.cursor()
        cur.execute("SELECT senha, precisa_trocar_senha FROM usuario WHERE usuario = %s", (usuario,))
        result = cur.fetchone()
        cur.close()
        disconnect_db(conn)

        if result:
            senha_armazenada = result[0]
            precisa_trocar = result[1]

            # Compat√≠vel com TEXT (str) e BYTEA (bytes)
            if isinstance(senha_armazenada, str):
                senha_armazenada = senha_armazenada.encode('utf-8')

            if bcrypt.checkpw(senha.encode('utf-8'), senha_armazenada):
                session['logado'] = True
                session['usuario'] = usuario

                if lembrar == 'on':
                    session.permanent = True
                    app.permanent_session_lifetime = timedelta(days=30)

                resp = redirect(url_for('alterar_senha') if precisa_trocar else url_for('adm'))

                if lembrar == 'on':
                    resp.set_cookie('usuario', usuario, max_age=60*60*24*30)
                else:
                    resp.set_cookie('usuario', '', expires=0)

                return resp
        

        return render_template('login.html', erro='Usu√°rio ou senha inv√°lidos.', usuario_cookie='', lembrar=False)

    usuario_cookie = request.cookies.get('usuario', '')
    lembrar = bool(usuario_cookie)
    return render_template('login.html', usuario_cookie=usuario_cookie, lembrar=lembrar)



@app.route('/logout')
def logout():
    session.pop('logado', None)

    return redirect(url_for('index'))

@app.route('/esqueci_senha', methods=['GET', 'POST'])
def esqueci_senha():
    if request.method == 'POST':
        email = request.form.get('email')
        # Aqui voc√™ pode adicionar l√≥gica para enviar o e-mail ou marcar a solicita√ß√£o
        return render_template('esqueci_senha.html', mensagem="Instru√ß√µes enviadas para seu e-mail.")
    return render_template('esqueci_senha.html')


# Rota para a p√°gina de esqueci a senha
@app.route('/alterar_senha', methods=['GET', 'POST'])
@login_requerido
def alterar_senha():
    if request.method == 'POST':
        nova_senha = request.form.get('nova_senha')
        confirmar = request.form.get('confirmar_senha')

        if nova_senha != confirmar:
            return render_template('alterar_senha.html', erro='As senhas n√£o coincidem.')

        # Gerar hash da nova senha
        senha_hash = bcrypt.hashpw(nova_senha.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')

        conn = connect_db()
        cur = conn.cursor()
        cur.execute("""
            UPDATE usuario 
            SET senha = %s, precisa_trocar_senha = FALSE 
            WHERE usuario = %s
        """, (senha_hash, session['usuario']))
        conn.commit()
        cur.close()
        disconnect_db(conn)

        return redirect(url_for('adm'))

    return render_template('alterar_senha.html')


@app.route('/adm')
@login_requerido
def adm():
    return render_template('adm.html')

@app.route('/calendario')
@login_requerido
def calendario():
    return render_template('calendar.html')

@app.route('/uploadcsv')
@login_requerido
def uploadcsv():
    return render_template('uploadcsv.html')




def insert_heroes_from_csv(file, data, loja, formato, cur):
    import time
    from io import StringIO
    import csv

    print("\nüöÄ In√≠cio: insert_heroes_from_csv (split inteligente)")
    t_start = time.time()

    content = file.read()
    lines = content.strip().splitlines()

    corrected_rows = []
    for i, line in enumerate(lines[1:], start=2):
        parts = line.split(',', 3)
        if len(parts) == 4:
            player_name = parts[0].strip().strip('"')
            player_id = parts[1].strip().strip('"')
            country = parts[2].strip().strip('"')
            hero = parts[3].strip().strip('"')
            corrected_rows.append([
                player_name, player_id, country, hero,
                data, loja, formato
            ])

    if not corrected_rows:
        print("‚ùó Nenhuma linha v√°lida encontrada no CSV.")
        raise ValueError("Nenhuma linha v√°lida encontrada no CSV.")

    print(f"üìÑ Linhas v√°lidas para inser√ß√£o: {len(corrected_rows)}")

    buffer = StringIO()
    writer = csv.writer(buffer, delimiter='\t', quoting=csv.QUOTE_NONE, escapechar='\\')
    writer.writerows(corrected_rows)
    buffer.seek(0)

    t_copy = time.time()
    cur.copy_from(
        buffer,
        'heroes',
        sep='\t',
        columns=('PlayerName', 'PlayerID', 'Country', 'Hero', 'Data', 'Loja', 'Formato')
    )
    print(f"‚ö° COPY executado em {round(time.time() - t_copy, 3)}s")
    print(f"‚úÖ Fim insert_heroes_from_csv em {round(time.time() - t_start, 3)}s")

    return "Dados inseridos com sucesso na tabela heroes!"

def insert_pairings_from_csv(file, data, loja, formato, cur):
    import time
    import csv
    from io import StringIO
    import pandas as pd

    print("\nüöÄ In√≠cio: insert_pairings_from_csv")
    t_start = time.time()

    df = pd.read_csv(file, encoding='utf-8-sig', dtype=str)
    print(f"üìÑ CSV lido: {len(df)} linhas")

    df['Data'] = data
    df['Loja'] = loja
    df['Formato'] = formato

    df = df[['Round', 'Table', 'Player 1 Name', 'Player 1 ID',
             'Player 2 Name', 'Player 2 ID', 'Result',
             'Data', 'Loja', 'Formato']]
    df = df.fillna('').astype(str)

    buffer = StringIO()
    df.to_csv(buffer, sep='\t', index=False, header=False, quoting=csv.QUOTE_NONE, escapechar='\\')
    buffer.seek(0)

    t_copy = time.time()
    cur.copy_from(
        buffer,
        'pairings',
        sep='\t',
        columns=('Round', 'Table', 'Player1Name', 'Player1ID',
                 'Player2Name', 'Player2ID', 'Result',
                 'Data', 'Loja', 'Formato')
    )
    print(f"‚ö° COPY executado em {round(time.time() - t_copy, 3)}s")
    print(f"‚úÖ Fim insert_pairings_from_csv em {round(time.time() - t_start, 3)}s")

    return "Dados inseridos com sucesso na tabela pairings!"

def insert_standings_from_csv(file, data, loja, formato, cur):
    import time
    import csv
    from io import StringIO
    import pandas as pd

    print("\nüöÄ In√≠cio: insert_standings_from_csv")
    t_start = time.time()

    df = pd.read_csv(file, encoding='utf-8-sig', dtype=str)
    print(f"üìÑ CSV lido: {len(df)} linhas")

    df['Data'] = data
    df['Loja'] = loja
    df['Formato'] = formato

    df = df[['Rank', 'Name', 'Player ID', 'Wins', 'Data', 'Loja', 'Formato']]
    df = df.rename(columns={'Player ID': 'PlayerID'})
    df = df.fillna('').astype(str)

    buffer = StringIO()
    df.to_csv(buffer, sep='\t', index=False, header=False, quoting=csv.QUOTE_NONE, escapechar='\\')
    buffer.seek(0)

    t_copy = time.time()
    cur.copy_from(
        buffer,
        'standings',
        sep='\t',
        columns=('Rank', 'Name', 'PlayerID', 'Wins', 'Data', 'Loja', 'Formato')
    )
    print(f"‚ö° COPY executado em {round(time.time() - t_copy, 3)}s")
    print(f"‚úÖ Fim insert_standings_from_csv em {round(time.time() - t_start, 3)}s")

    return "Dados inseridos com sucesso na tabela standings!"

def insert_calendar_entry(data, loja, cur):
    cur.execute("SELECT 1 FROM calendar WHERE data = %s AND loja = %s", (data, loja))
    exists = cur.fetchone()

    if not exists:
        cor = 'blue'  # ou l√≥gica de cor
        cur.execute("INSERT INTO calendar (data, loja, cor) VALUES (%s, %s, %s)", (data, loja, cor))
        return "Evento adicionado ao calend√°rio com sucesso!"
    else:
        return "Evento j√° existe no calend√°rio. Nenhuma a√ß√£o foi tomada."

def upload_to_box(file_stream, file_name, folder_name):
    from tokens_box import load_tokens, save_tokens

    access_token, refresh_token = load_tokens()

    oauth = OAuth2(
        client_id=os.getenv("BOX_CLIENT_ID"),
        client_secret=os.getenv("BOX_CLIENT_SECRET"),
        access_token=access_token,
        refresh_token=refresh_token,
        store_tokens=save_tokens
    )
    client = Client(oauth)

    try:
        # Encontra ou cria a pasta no Box
        root_folder = client.folder('0')
        folder_id = None

        for item in root_folder.get_items():
            if item.type == 'folder' and item.name == folder_name:
                folder_id = item.id
                break

        if folder_id is None:
            folder_id = root_folder.create_subfolder(folder_name).id

        folder = client.folder(folder_id)

        # Verifica se o arquivo j√° existe
        existing_file = None
        for item in folder.get_items():
            if item.name == file_name and item.type == 'file':
                existing_file = item
                break

        file_stream.seek(0)

        if existing_file:
            updated_file = existing_file.update_contents(file_stream)
            return f"‚úÖ Arquivo '{updated_file.name}' atualizado com sucesso na pasta '{folder_name}'!"
        else:
            uploaded_file = folder.upload_stream(file_stream, file_name)
            return f"‚úÖ Arquivo '{uploaded_file.name}' enviado para a pasta '{folder_name}' no Box com sucesso!"

    except Exception as e:
        return f"‚ùå Erro ao enviar arquivo para o Box: {repr(e)}"

from werkzeug.utils import secure_filename
import os
from io import BytesIO, StringIO

ALLOWED_EXTENSIONS = {'.csv'}

def allowed_file(filename):
    return os.path.splitext(filename)[1].lower() in ALLOWED_EXTENSIONS

@app.route('/upload', methods=['POST'])
def upload():
    conn = None
    try:
        # üîí Verifica√ß√£o de campos obrigat√≥rios
        required_fields = ['data', 'loja', 'formato', 'heroes', 'standings', 'pairings']
        for field in required_fields:
            if field not in request.form and field not in request.files:
                return f"‚ùå Campo obrigat√≥rio '{field}' n√£o foi fornecido.", 400

        # üîí Verifica√ß√£o de arquivos
        heroes_file = request.files['heroes']
        standings_file = request.files['standings']
        pairings_file = request.files['pairings']

        for f in [heroes_file, standings_file, pairings_file]:
            filename = secure_filename(f.filename)
            if not allowed_file(filename):
                return f"‚ùå Arquivo inv√°lido: {filename}. Apenas arquivos .csv s√£o permitidos.", 400

        # üîí L√™ dados bin√°rios
        heroes_data = heroes_file.read()
        standings_data = standings_file.read()
        pairings_data = pairings_file.read()

        data = request.form['data'].strip()
        loja = request.form['loja'].strip()
        formato = request.form['formato'].strip()
        pasta_box = f"{loja}_{data}_{formato}"

        # üîÑ In√≠cio da transa√ß√£o
        conn = connect_db()
        cur = conn.cursor()

        # Inser√ß√µes no banco (adiadas para antes do commit)
        result_heroes = insert_heroes_from_csv(StringIO(heroes_data.decode('utf-8-sig')), data, loja, formato, cur)
        result_standings = insert_standings_from_csv(StringIO(standings_data.decode('utf-8-sig')), data, loja, formato, cur)
        result_pairings = insert_pairings_from_csv(StringIO(pairings_data.decode('utf-8-sig')), data, loja, formato, cur)
        calendar_result = insert_calendar_entry(data, loja, cur)

        # üîí Commit apenas ap√≥s sucesso total
        conn.commit()

        # Uploads para o Box (fora da transa√ß√£o do banco)
        box_heroes = upload_to_box(BytesIO(heroes_data), secure_filename(heroes_file.filename), pasta_box)
        box_standings = upload_to_box(BytesIO(standings_data), secure_filename(standings_file.filename), pasta_box)
        box_pairings = upload_to_box(BytesIO(pairings_data), secure_filename(pairings_file.filename), pasta_box)

        if any(msg.startswith("‚ùå") for msg in [box_heroes, box_standings, box_pairings]):
            return f"""
            <b>Box Uploads:</b><br>
            {box_heroes}<br>
            {box_standings}<br>
            {box_pairings}<br><br>
            <b>‚ùå Erro:</b> Upload para o Box falhou. Os dados foram salvos no banco, mas n√£o no Box.
            """, 500

        return f"""
        <b>Box Uploads:</b><br>
        {box_heroes}<br>
        {box_standings}<br>
        {box_pairings}<br><br>

        <b>Inser√ß√£o no Banco:</b><br>
        {result_heroes}<br>
        {result_standings}<br>
        {result_pairings}<br><br>

        <b>Calend√°rio:</b><br>
        {calendar_result}
        """

    except Exception as e:
        if conn:
            conn.rollback()
        return f"‚ùå Erro no processamento geral do upload: {repr(e)}", 500
    finally:
        if conn:
            disconnect_db(conn)


@app.route('/calendar')
def calendar():
    conn = connect_db()
    cur = conn.cursor()
    cur.execute("SELECT data, loja, cor FROM calendar ORDER BY data")
    events = cur.fetchall()
    cur.close()
    disconnect_db(conn)

    from datetime import datetime
    event_list = []
    for data, loja, cor in events:
        if isinstance(data, str):
            data = datetime.strptime(data, "%Y-%m-%d").date()
        event_list.append({
            "title": loja,
            "start": data.strftime('%Y-%m-%d'),
            "className": f"event-{cor}"
        })

    return render_template("calendar.html", events_json=event_list)

@app.route('/auth')
def auth():
    oauth = OAuth2(
        client_id=os.getenv("BOX_CLIENT_ID"),
        client_secret=os.getenv("BOX_CLIENT_SECRET")
    )
    auth_url, _ = oauth.get_authorization_url('http://localhost:5000/callback')
    return f'<a href="{auth_url}">Clique aqui para autorizar o app no Box</a>'

@app.route('/callback')
def callback():
    from tokens_box import save_tokens

    code = request.args.get('code')
    oauth = OAuth2(
        client_id=os.getenv("BOX_CLIENT_ID"),
        client_secret=os.getenv("BOX_CLIENT_SECRET")
    )
    access_token, refresh_token = oauth.authenticate(code)
    save_tokens(access_token, refresh_token)
    return "‚úÖ Autenticado com sucesso! Tokens salvos."

@app.before_request
def log_csrf_check():
    if request.method == 'POST':
        print("üì® Requisi√ß√£o POST recebida, CSRF ser√° verificado.")

@app.after_request
def after_csrf_check(response):
    if request.method == 'POST':
        if response.status_code == 200:
            print("‚úÖ CSRF verificado com sucesso.")
        elif response.status_code == 400:
            print("‚ùå Falha na verifica√ß√£o do CSRF.")
    return response


if __name__ == '__main__':
    app.run(debug=True)  