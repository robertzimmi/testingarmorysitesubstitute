import os
import csv
import time
import json
import psycopg2
import pandas as pd
from io import BytesIO, StringIO
from dotenv import load_dotenv
from functools import wraps
from datetime import timedelta
import bcrypt


from flask import Flask, render_template, request, redirect, url_for, session, make_response, flash

from flask_wtf.csrf import CSRFProtect, generate_csrf
from boxsdk import Client, OAuth2




app = Flask(__name__)
app.config['SECRET_KEY'] = os.getenv('SECRET_KEY')
from flask_wtf.csrf import CSRFProtect
csrf = CSRFProtect(app)


def connect_db():
    required_vars = ["DB_NAME", "DB_USER", "DB_PASSWORD", "DB_HOST"]
    for var in required_vars:
        if not os.getenv(var):
            raise EnvironmentError(f"‚ùå Vari√°vel de ambiente n√£o definida: {var}")
    
    return psycopg2.connect(
        dbname=os.getenv("DB_NAME"),
        user=os.getenv("DB_USER"),
        password=os.getenv("DB_PASSWORD"),
        host=os.getenv("DB_HOST"),
        port=os.getenv("DB_PORT", "5432")
    )

# Fun√ß√£o para desconectar do banco
def disconnect_db(conn):
    if conn:
        conn.close()

def login_requerido(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not session.get('logado'):
            return redirect(url_for('login'))
        return f(*args, **kwargs)
    return decorated_function        

@app.route('/')
def index():
    return render_template('home.html')  # ‚Üê correto para usar {{ csrf_token() }}
# Rota para a p√°gina de login
from flask import flash  # importe flash no in√≠cio do seu arquivo

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        usuario = request.form.get('usuario')
        senha = request.form.get('senha')
        lembrar = request.form.get('lembrar')

        conn = connect_db()
        cur = conn.cursor()
        cur.execute("SELECT senha, precisa_trocar_senha FROM usuario WHERE usuario = %s", (usuario,))
        result = cur.fetchone()
        cur.close()
        disconnect_db(conn)

        if result:
            senha_armazenada = result[0]
            precisa_trocar = result[1]

            # Compat√≠vel com TEXT (str) e BYTEA (bytes)
            if isinstance(senha_armazenada, str):
                senha_armazenada = senha_armazenada.encode('utf-8')

            if bcrypt.checkpw(senha.encode('utf-8'), senha_armazenada):
                session['logado'] = True
                session['usuario'] = usuario

                if lembrar == 'on':
                    session.permanent = True
                    app.permanent_session_lifetime = timedelta(days=30)

                resp = redirect(url_for('alterar_senha') if precisa_trocar else url_for('base'))

                if lembrar == 'on':
                    resp.set_cookie('usuario', usuario, max_age=60*60*24*30)
                else:
                    resp.set_cookie('usuario', '', expires=0)

                return resp

        # Se chegar aqui, usu√°rio ou senha inv√°lidos
        flash('Usu√°rio ou senha inv√°lidos.', 'error')
        return render_template('login.html', usuario_cookie=usuario, lembrar=(lembrar == 'on'))


    usuario_cookie = request.cookies.get('usuario', '')
    lembrar = bool(usuario_cookie)
    return render_template('login.html', usuario_cookie=usuario_cookie, lembrar=lembrar)



@app.route('/logout')
def logout():
    session.pop('logado', None)

    return redirect(url_for('index'))

@app.route('/esqueci_senha', methods=['GET', 'POST'])
def esqueci_senha():
    if request.method == 'POST':
        usuario = request.form.get('usuario')

        conn = connect_db()
        cur = conn.cursor()

        cur.execute("SELECT * FROM usuario WHERE usuario = %s", (usuario,))
        resultado = cur.fetchone()

        if resultado:
            # Gerar hash da nova senha padr√£o
            senha_padrao = 'senha1234'
            senha_hash = bcrypt.hashpw(senha_padrao.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')

            cur.execute("""
                UPDATE usuario
                SET precisa_trocar_senha = TRUE, senha = %s
                WHERE usuario = %s
            """, (senha_hash, usuario))
            conn.commit()
            mensagem = "Senha redefinida. Use 'senha1234' para entrar e altere sua senha ao acessar o sistema."
        else:
            mensagem = "Usu√°rio n√£o encontrado."

        cur.close()
        disconnect_db(conn)
        return render_template('esqueci_senha.html', mensagem=mensagem)

    return render_template('esqueci_senha.html')




# Rota para a p√°gina de esqueci a senha
@app.route('/alterar_senha', methods=['GET', 'POST'])
@login_requerido
def alterar_senha():
    if request.method == 'POST':
        nova_senha = request.form.get('nova_senha')
        confirmar = request.form.get('confirmar_senha')

        if nova_senha != confirmar:
            return render_template('alterar_senha.html', erro='As senhas n√£o coincidem.')

        # Gerar hash da nova senha
        senha_hash = bcrypt.hashpw(nova_senha.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')

        conn = connect_db()
        cur = conn.cursor()
        cur.execute("""
            UPDATE usuario 
            SET senha = %s, precisa_trocar_senha = FALSE 
            WHERE usuario = %s
        """, (senha_hash, session['usuario']))
        conn.commit()
        cur.close()
        disconnect_db(conn)

        return redirect(url_for('base'))

    return render_template('alterar_senha.html')


@app.route('/base')
@login_requerido
def base():
    return render_template('base.html')

@app.route('/calendario')
@login_requerido
def calendario():
    return render_template('calendar.html')

@app.route('/uploadcsv')
@login_requerido
def uploadcsv():
    return render_template('uploadcsv.html')




def insert_heroes_from_csv(file, data, loja, formato, cur):
    import time
    from io import StringIO
    import csv
    from flask import session, flash

    t_start = time.time()
    usuario = session.get("usuario", "desconhecido")

    content = file.read()
    lines = content.strip().splitlines()

    corrected_rows = []
    for i, line in enumerate(lines[1:], start=2):
        parts = line.split(',', 3)
        if len(parts) == 4:
            player_name = parts[0].strip().strip('"')
            player_id = parts[1].strip().strip('"')
            country = parts[2].strip().strip('"')
            hero = parts[3].strip().strip('"')
            corrected_rows.append([
                player_name, player_id, country, hero,
                data, loja, formato, usuario
            ])

    if not corrected_rows:
        flash("‚ùó Nenhuma linha v√°lida encontrada no CSV.", "warning")
        raise ValueError("Nenhuma linha v√°lida encontrada no CSV.")

    flash(f"üìÑ Linhas v√°lidas para inser√ß√£o: {len(corrected_rows)}", "info")

    buffer = StringIO()
    writer = csv.writer(buffer, delimiter='\t', quoting=csv.QUOTE_NONE, escapechar='\\')
    writer.writerows(corrected_rows)
    buffer.seek(0)

    cur.copy_from(
        buffer,
        'heroes',
        sep='\t',
        columns=('PlayerName', 'PlayerID', 'Country', 'Hero', 'Data', 'Loja', 'Formato', 'usuario')
    )
    return "Dados inseridos com sucesso na tabela heroes!"

def insert_pairings_from_csv(file, data, loja, formato, cur):
    import time
    import csv
    from io import StringIO
    import pandas as pd
    from flask import session

    t_start = time.time()
    usuario = session.get("usuario", "desconhecido")

    df = pd.read_csv(file, encoding='utf-8-sig', dtype=str)

    df['Data'] = data
    df['Loja'] = loja
    df['Formato'] = formato
    df['usuario'] = usuario

    df = df[['Round', 'Table', 'Player 1 Name', 'Player 1 ID',
             'Player 2 Name', 'Player 2 ID', 'Result',
             'Data', 'Loja', 'Formato', 'usuario']]
    df = df.fillna('').astype(str)

    buffer = StringIO()
    df.to_csv(buffer, sep='\t', index=False, header=False, quoting=csv.QUOTE_NONE, escapechar='\\')
    buffer.seek(0)

    cur.copy_from(
        buffer,
        'pairings',
        sep='\t',
        columns=('Round', 'Table', 'Player1Name', 'Player1ID',
                 'Player2Name', 'Player2ID', 'Result',
                 'Data', 'Loja', 'Formato', 'usuario')
    )

    return "Dados inseridos com sucesso na tabela pairings!"

def insert_standings_from_csv(file, data, loja, formato, cur):
    import time
    import csv
    from io import StringIO
    import pandas as pd
    from flask import session

    t_start = time.time()
    usuario = session.get("usuario", "desconhecido")

    df = pd.read_csv(file, encoding='utf-8-sig', dtype=str)

    df['Data'] = data
    df['Loja'] = loja
    df['Formato'] = formato
    df['usuario'] = usuario

    df = df[['Rank', 'Name', 'Player ID', 'Wins', 'Data', 'Loja', 'Formato', 'usuario']]
    df = df.rename(columns={'Player ID': 'PlayerID'})
    df = df.fillna('').astype(str)

    buffer = StringIO()
    df.to_csv(buffer, sep='\t', index=False, header=False, quoting=csv.QUOTE_NONE, escapechar='\\')
    buffer.seek(0)

    cur.copy_from(
        buffer,
        'standings',
        sep='\t',
        columns=('Rank', 'Name', 'PlayerID', 'Wins', 'Data', 'Loja', 'Formato', 'usuario')
    )

    return "Dados inseridos com sucesso na tabela standings!"


def insert_calendar_entry(data, loja, cur):
    from flask import session

    usuario = session.get("usuario", "desconhecido")

    cur.execute("SELECT 1 FROM calendar WHERE data = %s AND loja = %s", (data, loja))
    exists = cur.fetchone()

    if not exists:
        loja_lower = loja.lower()
        if "bolovo" in loja_lower:
            cor = 'blue'
        elif "caverna" in loja_lower:
            cor = 'red'
        elif "arena" in loja_lower:
            cor = 'orange'
        else:
            cor = 'blue'

        cur.execute(
            "INSERT INTO calendar (data, loja, cor, usuario) VALUES (%s, %s, %s, %s)",
            (data, loja, cor, usuario)
        )
        return "Evento adicionado ao calend√°rio com sucesso!"
    else:
        return "Evento j√° existe no calend√°rio. Nenhuma a√ß√£o foi tomada."



def upload_to_box(file_stream, file_name, folder_name):
    from app.tokens_box import load_tokens, save_tokens

    access_token, refresh_token = load_tokens()

    oauth = OAuth2(
        client_id=os.getenv("BOX_CLIENT_ID"),
        client_secret=os.getenv("BOX_CLIENT_SECRET"),
        access_token=access_token,
        refresh_token=refresh_token,
        store_tokens=save_tokens
    )
    client = Client(oauth)

    try:
        # Encontra ou cria a pasta no Box
        root_folder = client.folder('0')
        folder_id = None

        for item in root_folder.get_items():
            if item.type == 'folder' and item.name == folder_name:
                folder_id = item.id
                break

        if folder_id is None:
            folder_id = root_folder.create_subfolder(folder_name).id

        folder = client.folder(folder_id)

        # Verifica se o arquivo j√° existe
        existing_file = None
        for item in folder.get_items():
            if item.name == file_name and item.type == 'file':
                existing_file = item
                break

        file_stream.seek(0)

        if existing_file:
            updated_file = existing_file.update_contents(file_stream)
            return f"‚úÖ Arquivo '{updated_file.name}' atualizado com sucesso na pasta '{folder_name}'!"
        else:
            uploaded_file = folder.upload_stream(file_stream, file_name)
            return f"‚úÖ Arquivo '{uploaded_file.name}' enviado para a pasta '{folder_name}' no Box com sucesso!"

    except Exception as e:
        return f"‚ùå Erro ao enviar arquivo para o Box: {repr(e)}"

from werkzeug.utils import secure_filename
import os
from io import BytesIO, StringIO

ALLOWED_EXTENSIONS = {'.csv'}

def allowed_file(filename):
    return os.path.splitext(filename)[1].lower() in ALLOWED_EXTENSIONS

@app.route('/upload', methods=['POST'])
def upload():
    conn = None
    try:
        # üîí Verifica√ß√£o de campos obrigat√≥rios
        required_fields = ['data', 'loja', 'formato', 'heroes', 'standings', 'pairings']
        for field in required_fields:
            if field not in request.form and field not in request.files:
                return f"‚ùå Campo obrigat√≥rio '{field}' n√£o foi fornecido.", 400

        # üîí Verifica√ß√£o de arquivos
        heroes_file = request.files['heroes']
        standings_file = request.files['standings']
        pairings_file = request.files['pairings']

        for f in [heroes_file, standings_file, pairings_file]:
            filename = secure_filename(f.filename)
            if not allowed_file(filename):
                return f"‚ùå Arquivo inv√°lido: {filename}. Apenas arquivos .csv s√£o permitidos.", 400

        # üîí L√™ dados bin√°rios
        heroes_data = heroes_file.read()
        standings_data = standings_file.read()
        pairings_data = pairings_file.read()

        data = request.form['data'].strip()
        loja = request.form['loja'].strip()
        formato = request.form['formato'].strip()
        pasta_box = f"{loja}_{data}_{formato}"

        # üîÑ In√≠cio da transa√ß√£o
        conn = connect_db()
        cur = conn.cursor()

        # Inser√ß√µes no banco (adiadas para antes do commit)
        result_heroes = insert_heroes_from_csv(StringIO(heroes_data.decode('utf-8-sig')), data, loja, formato, cur)
        result_standings = insert_standings_from_csv(StringIO(standings_data.decode('utf-8-sig')), data, loja, formato, cur)
        result_pairings = insert_pairings_from_csv(StringIO(pairings_data.decode('utf-8-sig')), data, loja, formato, cur)
        calendar_result = insert_calendar_entry(data, loja, cur)

        # üîí Commit apenas ap√≥s sucesso total
        conn.commit()

        # Uploads para o Box (fora da transa√ß√£o do banco)
        box_heroes = upload_to_box(BytesIO(heroes_data), secure_filename(heroes_file.filename), pasta_box)
        box_standings = upload_to_box(BytesIO(standings_data), secure_filename(standings_file.filename), pasta_box)
        box_pairings = upload_to_box(BytesIO(pairings_data), secure_filename(pairings_file.filename), pasta_box)

        if any(msg.startswith("‚ùå") for msg in [box_heroes, box_standings, box_pairings]):
            flash("‚ùå Upload para o Box falhou. Os dados foram salvos no banco, mas n√£o no Box.", "error")
            flash(box_heroes, "error")
            flash(box_standings, "error")
            flash(box_pairings, "error")
            return redirect(url_for('uploadcsv'))

        flash(box_heroes, "success")
        flash(box_standings, "success")
        flash(box_pairings, "success")
        flash(result_heroes, "success")
        flash(result_standings, "success")
        flash(result_pairings, "success")
        flash(calendar_result, "info")
        return redirect(url_for('uploadcsv'))

    except Exception as e:
        if conn:
            conn.rollback()
        flash(f"‚ùå Erro no processamento geral do upload: {repr(e)}", "error")
        return redirect(url_for('uploadcsv'))


@app.route('/calendar')
def calendar():
    conn = connect_db()
    cur = conn.cursor()
    cur.execute("SELECT data, loja, cor FROM calendar ORDER BY data")
    events = cur.fetchall()
    cur.close()
    disconnect_db(conn)

    from datetime import datetime
    event_list = []
    for data, loja, cor in events:
        if isinstance(data, str):
            data = datetime.strptime(data, "%Y-%m-%d").date()
        event_list.append({
            "title": loja,
            "start": data.strftime('%Y-%m-%d'),
            "className": [f"event-{cor}"]  # üëà Aqui √© o ajuste principal
        })

    return render_template("calendar.html", events_json=event_list)


    from datetime import datetime
    event_list = []
    for data, loja, cor in events:
        if isinstance(data, str):
            data = datetime.strptime(data, "%Y-%m-%d").date()
        event_list.append({
            "title": loja,
            "start": data.strftime('%Y-%m-%d'),
            "className": f"event-{cor}"
        })

    return render_template("calendar.html", events_json=event_list)

@app.route('/auth')
def auth():
    oauth = OAuth2(
        client_id=os.getenv("BOX_CLIENT_ID"),
        client_secret=os.getenv("BOX_CLIENT_SECRET")
    )
    auth_url, _ = oauth.get_authorization_url('http://localhost:5000/callback')
    return f'<a href="{auth_url}">Clique aqui para autorizar o app no Box</a>'

@app.route('/callback')
def callback():
    from app.tokens_box import save_tokens

    code = request.args.get('code')
    oauth = OAuth2(
        client_id=os.getenv("BOX_CLIENT_ID"),
        client_secret=os.getenv("BOX_CLIENT_SECRET")
    )
    access_token, refresh_token = oauth.authenticate(code)
    save_tokens(access_token, refresh_token)
    return "‚úÖ Autenticado com sucesso! Tokens salvos."

@app.before_request
def log_csrf_check():
    if request.method == 'POST':
        print("üì® Requisi√ß√£o POST recebida, CSRF ser√° verificado.")

@app.after_request
def after_csrf_check(response):
    if request.method == 'POST':
        if response.status_code == 200:
            ("‚úÖ CSRF verificado com sucessoprint.")
        elif response.status_code == 400:
            print("‚ùå Falha na verifica√ß√£o do CSRF.")
    return response


if __name__ == '__main__':
    app.run(debug=True)
